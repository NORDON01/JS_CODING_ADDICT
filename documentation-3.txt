
/*==================== J A V A S C R I P T ====================*/

*****************
3 ways to code JS
*****************
Inline, internal, external.

Place the internal code after the HTML !
Internal code affects the only page where it stands.
The call to the external code can also be in the 
"HEAD" with a "defer" mention.

*********
3 helpers
*********
document.write("Hello world 1");
alert("Hello world 2");
console.log("Hello world 3");

document.write({name:"John"})

*********
VARIABLES
*********
--let;
let log = console.log;
log(name) ==> undefined

--const name = "Paul"; cannot be reassigned
--var is the same as let

*******
NUMBERS
*******
integers and decimals
Les nombres sont en bleu et les
chaînes de caractères en noir. 

- Ex1
let variable = 40;
variable += 5;
variable++;

log(variable);  //  46

-Ex2
let num1 = "10";
let num2 = "32";

let add = num1 + num2;
log(add);       // 1032

let sub = num1 - num2;
log(sub);       -22

**********
DATA TYPES
**********
Primitive:
String, Number, Boolean, Null, Undefined, Symbol

Object:
Arrays, Functions, Objects

- Ex1
const log = console.log;

let texte = "Ceci est un essai";
log(typeof texte); //string
log(typeof true);  //boolean

******
ARRAYS
******
-Ex1
const friends = ["john", "peter", "bob", "suzy", 45, undefined, null];

log(friends[6]); //null

let bestFriend = friends[3];
log(bestFriend); //suzy

friends[4] = "ANNA";
log(friends);
// ["john", "peter", "bob", "suzy", "ANNA", undefined, null];

****************
DECLARE - INVOKE
****************
//Declare
function hello() {
  log("Hello there Bob");
  log("Hello there Anna");
  log("Hello there Suzy");
}
//Invoke
hello();

**********************
PARAMETERS - ARGUMENTS
**********************
    Parameters are placeholders or variables
and arguments are values for these variables.    

-Ex1
function greet(name) {  //Paramètre
  let yourName = name;
  log("hello " + yourName);
}

greet("Paul");  // Argument - hello Paul

//OU

let fname = "Peter";
greet(fname);   //hello Peter

*******************
FUNCTION EXPRESSION
*******************
L'idée consiste à affecter une fonction à 
une variable et à utiliser cette variable
pour "invoker" la fonction.

-Ex1
function addition(para1, para2) {
  return para1 + para2;
} 

log(addition(5, 6));  //11

let add = function addition(para1, para2) {
  return para1 + para2;
};

log(add(21, 4));function addition(para1, para2) {
  return para1 + para2;
} 

log(addition(5, 6));  //11

let add = function addition(para1, para2) {
  return para1 + para2;
};

log(add(21, 4));   function addition(para1, para2) {
  return para1 + para2;
} 

log(addition(5, 6));  //11

let add = function addition(para1, para2) {
  return para1 + para2;
};

log(add(21, 4));    //25

   Le nom de la fonction (addition) peut être
omis lors de l'assignation de la fonction
addition à la variable add. On parle de fonction
anonyme.

-Ex2
multiply= (num1, num2) => (num1 * num2);

*******
OBJECTS
*******
const person = {
  name: "John",       //property & value
  lastName: "Peters",
  age: 42,
  education: false,
  married: true,
  siblings: ["anna", "susan", "peter"],
  greeting: function () {     //method
    log("Hello my name is JOHN");
  },
};

log(person.name);

**********************
CONDITIONAL STATEMENTS
**********************
   >, <, >=, <=, ==, ===, !=, !===

Syntaxe:
if(condition) {faire 1}
else {faire 2}

-Ex1
const value1 = 2 > 1;
const value2 = 1 > 2;

if (value2) {
  log("Cette proposition est vraie");
} else {
  log("Cette proposition est fausse");
}   //Cette proposition est fausse  

-Ex2
const num1 = 8;
const num2 = 7;

if (num1 > num2) {
  log("num1 est supérieur à num2");
} else if (num1 < num2) {
  log("num1 est inférieur à num2");
} else {
  log("num1 et num2 sont égaux");
}
//num1 est supérieur à num2

********
EQUALITY
********
num1 = 6;
log(num1 + " is a " + typeof num1);
num2 = "6";
log(num2 + " is a " + typeof num2);

let value = num1 == num2;
log(value + " num1 equals num2");

value = num1 === num2;
log(value + " num1 & num2 are not the same type");

*****************
LOGICAL OPERATORS
*****************
|| - OR; && - AND

******
SWITCH
******

let dice = "A";
switch (dice) {
  case 1: {
    log("You got the 1");
    break;
  }
  case 2: {
    log("You got the 2");
    break;
  }
  case 3: {
    log("You got the 3");
    break;
  }
  default: {
    log("You did not roll the dice ");
    break;
  }
}     //You did not roll the dice

*****
LOOPS
*****
==> while loop
You need to create an escape condition 
within the loop !

Syntax:
while{

}
   The condition is tested first (before the
  code)

==> do while loop
Syntax:
do{
 code
}

while(condition)
 The condition is tested after the code;
 The code will be executed at least once.

==>for loop
for (let i = 0; i < 10; i++) {
  log(i);
}

/*==================== J S  C O N T I N U E D ====================*/

***************************
STRING PROPERTIES & METHODS
***************************
js string methods:
https://www.w3schools.com/js/js_string_methods.asp

OU mozilla:

https://developer.mozilla.org/en-US/
puis Javascript puis Standard built-in objects
puis String

-Ex1
//Properties
let text = "  Peter Jordan ";
log(text.length); //12
//Methods
let result = text.toLowerCase();
log(result);
result = text.toUpperCase();
log(result);
result = text.charAt(2);
log(result); //t
log(text.charAt(text.length - 1)); //Donne le dernier caractère: n
log(text.indexOf("P")); //0

text = "  Peter Jordan "; //Supprime les blancs autour
result = text.trim();
log(result);                    //Peter Jordan

log(text.startsWith("peter")); //false
log(text.includes("eter"));    //true
log(text.slice(0, 2))          //"Pe"

*****************
TEMPLATE LITERALS
*****************
-Ex1
const fname = "John";
const age = 25;

let value = `Hey here is ${fname} and he is 
${age} years old. And here is some simple math ${4 + 4}`;

log(value);

-Ex2
function expression:
const fullName = (fname, lname) => {
  let result = `${fname} ${lname}`;
  result.toUpperCase();
  return result;
};
invoke function:
log(fullName("Georges", "NORDON"));
log(fullName("NORDON", "Georges"));

**************************
ARRAY PROPERTIES & METHODS
**************************
//length
let names = ["John", "Bobo", "Mary", "Olga", "Ben"];
log("Length: " + names.length);
let lastItem = names[names.length - 1];
log("Last item: " + lastItem);

//concat
let lastNames = ["pepper", "onion", "banana"];
let fullNames = names.concat(lastNames);
log(fullNames);

//reverse
log(fullNames.reverse());

//unshift(Add at the beginning of the array)
fullNames.unshift("Toto");
log(fullNames);

//shift (remove the first item)
fullNames.shift();
log(fullNames);

//push(Add at the end)
fullNames.push("Toto");
log(fullNames);

//pop(Remove from the end)
fullNames.pop();
log(fullNames);

//splice - mutates the original array
log(fullNames);
let tranche = fullNames.splice(2, 2);
log(tranche);
log(fullNames);

******************
VALUE VS REFERENCE
******************
When using a primitive type (String, integer...) 
and changing the value of a copy of the 
original, any change will affect the copy
(not the original).

When using a non primitive type (Array, 
function, object) any change of the copy
will also change the original.


******************
NULL AND UNDEFINED
******************
undefined: a value, arguments or properties are missing.
null: a choice of the programmer.

**************
TRUTHY & FALSY
**************
"",'',``, 0, -0, NaN,
false, null, undefined
Autant de termes qui peuvent être falsy si la syntaxe
est mauvaise.
Par défaut, les expressions sont truthy.

****************
TERNARY OPERATOR
****************
unary operator
binary operator
ternary operator

Another way of writing "if...else":
value ? (runs if true) : (runs if false);

-Ex1
let valeur = 4 < 3 ;

valeur ? log('Valeur est plutôt vraie'): 
log('Valeur est assez fausse') // Valeur est assez fausse

***************************************
GLOBAL SCOPE & LOCAL SCOPE OF VARIABLES
***************************************
Local scope : code within {} braces.
Global scope: code outside of such blocks.
Beware of name collisions and about modifying
a global variable by mistake.

Let/const and var perform differently when it comes 
to blocks/functions (which use {}).

Attention une variable à l'intérieur d'une fonction 
qui serait déclarée sans let/const devient globale (accessible
depuis l'extérieur de la fonction )

***************
VARIABLE LOOKUP
***************

const globalNumber = 10;

function add (num1, num2){
    const globalNumber = 20;
    let addResult = num1 + num2 + globalNumber;
    log(addResult);                 /* 27 */
    

    function multiply() {
    <---!  const globalNumber = 5; --->   
        let multiplyResult = addResult * globalNumber; /* addResult est visible !!!  */
        log(multiplyResult);    /* 540 */ (20 * 27)
    }
   multiply();           /* On invoque multiply */

   return addResult      /* On retourne addResult, sinon log(add(3, 4)) donne undefined */
}

log(add(3, 4))           /* On invoque add */

***************************************************************
CALL BACK, HIGHER ORDER FUNCTIONS, FIRST CLASS OBJECTS/CITIZENS
***************************************************************
- A higher order function is a function which takes another
function as an argument or returns another function as a result.
- A callback function is a function which is being passed
to another function and executed in this function.

-Ex1
const log = console.log;

let goodMorning = (fname) => {return(`Good morning ${fname}`)};

let greet = (fname, cb) => {
    let myName = 'Georges';
    log(`My name is ${myName}, ${cb(fname)}`)
}
    
greet('Tartampion', goodMorning);   //cb est remplacé par 'goodMorning' et fname par 'Tartampion' 

goodMorning is a callback function !!!

-Ex2
let goodMorning = (yourName) => {return(`Good morning ${yourName}`)}

log(goodMorning('Toto'));

let greet = (votreNom, cb) => {
    const myName = 'Georges';
    log(`My name is ${myName} ${cb(votreNom)}`)
}

greet('Max', goodMorning);

The LOOKUP is always from the function inside to 
the function outside (or at the function at the same level)!!!

***************
ARRAY ITERATORS
***************
forEach, map, filter, find, reduce.

*******
FOREACH
*******
forEach does not return a new array !!!
On n'"invoke" pas la fonction, elle est simplement passée au forEach

let people = [
    {name:'bob', age:20, position: 'developer'},
    {name:'peter', age:40, position: 'designer'},
    {name:'suzan', age:25, position: 'the boss'}
]

/* -Ex1 */
let showPerson = function (person) {
    log(person.position.toUpperCase())
}

people.forEach(showPerson);//La liste des personnes s'affiche ! Pas d'"invoke"

/* -Ex2 */
people.forEach(function(item){
   log(item.position.toUpperCase());    //On utilise une fonction anonyme
})

***
MAP
***
Very usefull !
It does return a new array.
It does not change the size of the original array.

-Ex1
let people = [
    {name:'bob', age:20, position: 'developer'},
    {name:'peter', age:25, position: 'designer'},
    {name:'suzan', age:30, position: 'the boss'}
]

let newPeople = people.map(function(person){
    log(person);
    return {
        fname: person.name.toUpperCase(),
        age: person.age +20
    }
});

log(newPeople);

******
FILTER
******
Filter returns a new array;
But size of the array can be different from the original
depending on condition;

-Ex1
let developers = people.filter(function (item) {
    return item.position === 'developer';
})

log(developers);

****
FIND
****
Find returns a single object (item);
It returns the first match;

-Ex1
const person1 = people.find(function(person){
    return person.name === 'peter';
})

log(person1);
log(person1.name);

******
REDUCE
******
  Reduce takes 2 parameters plus an initial value: 
    - acc the accumulator which MUST BE RETURNED;
    - curr (or currItem), the current item;
  The initial value can be an integer, an array or an object.
  Depending on the initial value, the accumulator (acc) will 
  be an integer, an array or an object.


let people = [
    {name:'bob', age:20, position: 'developer', salary: 200},
    {name:'peter', age:25, position: 'designer', salary: 300},
    {name:'suzan', age:30, position: 'the boss', salary: 500},
    {name:'anna',  age:35, position: 'the boss', salary: 500}
]

const total = people.reduce(function(acc, currItem){
        log(`Total ${acc}`);
        log(`Current money: ${currItem.salary}`);
        acc += currItem.salary;
    return acc;            //COMPULSORY    
}, 0);                     //initial value 0 => acc will be an integer

log(`Total : ${total}`);

**************
MULTIPLE FILES
**************
  Il s'agit de créer un fichier de données 
  "students.js" distinct du fichier "app.js".
  Pour cela couper/coller l'array des "students" 
  dans le fichier "students.js".
  Puis dans le fichier "index.html" appeler le
  fichier "students.js":
    <script src="./students.js"></script>

*********
CHALLENGE
*********
log(students);  
//Ajout d'une propriété
let newStudents = students.map(function(student){
    student.role = 'student';
    return student;
})

log (newStudents);

//Sélection des meilleurs étudiants
let highScores = students.filter(function(student){
   return student.score >= 80;
   //ou if(student.score >= 80){return student} 
})

log(highScores);

//Sélection de l'étudiant avec l'id === 1
let singleStudent = students.find(function(student){
    return student.id === 1;
})

log (singleStudent);

//Calcul du score moyen
let averageScore = students.reduce(function (acc, student){
    log(student.id);
    log(`${acc}`);
    acc += student.score;
    return acc;
},0)/students.length;

log(`Average score: ${averageScore}`);

***************
SQUARE BRACKETS
***************
const subject = art;
const total = {};             //un accumulateur (~acc)

total[subject] = 'some value' //un accumulateur pour une valeur

- Ex1
let survey = students.reduce(function(survey, student){
    let favSubject = student.favoriteSubject;

    if(survey[favSubject]){survey[favSubject]++}
    else{survey[favSubject] = 1};

    return(survey)   
}, {});

log(survey);

***********
MATH OBJECT
***********
Math.floor(number), Math.ceil(number),
Math.sqrt(number),
Math.PI,
Math.min(3,5,8,1,50), Math.max(3,5,8,1,50),
Math.random()   //De 0 à 0.9999999

***********
DATE OBJECT
***********
  1 - const date = new Date();  //Possibilité d'utiliser une autre date
  
  2 - const moiss = ['Janvier', 'Février', 'Mars', 'Avril',
                      'Mai','Juin', 'Juillet', 'Août',
                      'Septembre',Octobre', 'Novembre', 'Décembre'];
      const jours = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi',
                    'Jeudi', 'Vendredi', 'Samedi',]
  3 - 
    let indexm = date.getMonth();
      let mois = moiss[indexm]
      log(mois);
      
      let indexj = date.getDay();
      let joursem = jours[indexj];                                       
      log(joursem);

      let jourmoi = date.getDate();
      log(jourmoi);  

      let an = date.getFullYear();     
      log(an);

      let sentence = `${joursem}, ${jourmoi} ${mois} ${an}`;
      log(sentence); 

      document.body.innerHTML = sentence;


      /******************D O C U M E N T  O B J E C T  M O D E L ******************/

    *******
    THE DOM
    *******
      A node object or node list is an array like object.

    *****************
    WINDOW & DOCUMENT
    *****************
    - The window object ou "browser api";
    document: une propriété de l'objet window. 
    - On devrait écrire "window.document".
    - console.dir(document); //Pour voir le contenu de window.document
     
**************
GETELEMENTBYID
**************
const h1 = document.getElementById("title");
log(h1);
h1.style.color = "red";

const btn = document.getElementById("btn");
log(btn);
btn.style.background = "blue";
btn.style.color = "white"

********************
GETELEMENTSBYTAGNAME
********************
<body>
    <h2 id="title">Hello world</h2>
    <h2>Hello people</h2>

    <ul class="result">
      <li class="special">apple</li>
      <li class>orange</li>
      <li class="special">banana</li>
      <li class=>pear</li>
      <li class="special last">tomato</li>
    </ul>
    
  </body>

const headings = document.getElementsByTagName('h2');
log(headings); //An HTML collection, unlike an array, cannot use forEach
headings[0].style.color = 'red';  

const fruits = document.getElementsByTagName('li');
const fruitsArray = [...fruits]; //Spread changes fruits into an array
fruitsArray.forEach(function(fruit){
    log(fruit);
})

log(fruits);                    //Affiche HTML Collection
log(fruitsArray);               //Affiche un Array

**********************
GETELEMENTSBYCLASSNAME
**********************
const log = console.log;    //global scope

const fruits = document.getElementsByClassName('special');
log(fruits);                //HTML Collection 

fruits[2].style.color = 'red';

let newFruits = [...fruits];
log(newFruits);             //Array

********************************
QUERYSELECTOR - QUERYSELECTORALL
********************************
  Syntaxe: let item = document.querySelector('any selector');
           let items = document.querySelectorAll('any selector');

 const log = console.log;    //global scope

const fruit = document.querySelector('.special');
log(fruit);         //SÉLECTION DU 1er fruit de la classe ".special"  

const fruits = document.querySelectorAll('.special');
                    //BIEN INDIQUER '.' OU '#'
log(fruits);        //CECI EST UN ARRAY (une NODELIST) => FOREACH est possible

fruits.forEach(function(fruit){
    log(fruit);
})

/********************** N A V I G A T E  T H E  D O M **********************/

********
CHILDREN
********
- Ex1    
 <ul id="result">
      <li class="special">apple</li>
      <li class>orange</li>
      <li class="special">banana</li>
      <li class=>pear</li>
      <li class="special last">tomato</li> 
    </ul>

const log = console.log;            //global scope

const fruits = document.q uerySelector('#result');
log(fruits);                         //Retourne l'objet ul

let children = fruits.children;     
log(children);                      //Ceci est une HTML Collection

log(children[0]);                   //'apple'
log(fruits.firstChild);             //text ? node de type 3
log(fruits.lastChild);              //text ? node de type 3

L'utilisation de childnodes (!= children) génère des nodes 
de type "text" là où il y a des blancs

**************
PARENT ELEMENT
**************
  <head>
  .../..
  </head>
  <body>
   <div id="result">
    <h1>Hello world</h1>
    <div class="second">
      <h2>second heading</h2>
      <h3>another heading</h3>
    </div>
   </div>
  </body>

  const heading1 = document.querySelector('h1');
  log(heading1.parentElement);

log(heading2.parentElement.parentElement);
log(heading2.parentElement.parentElement.parentElement);
log(heading2.parentElement.parentElement.parentElement.parentElement);

***********************
NEXT / PREVIOUS SIBLING
***********************
  <ul>
      <li class="first">first</li>
      <li>listItem2</li>
      <li>listItem3</li>
      <li id="last">last</li>
  </ul>

  /* next sibling */
const first = document.querySelector('.first')
let suivant = first.nextSibling.nextSibling;   //2 fois "nextSibling" sinon on tombe
                                               // sur un blanc et "#text"
let liste = document.querySelector('ul');
log(liste);

log(suivant.style.color= 'red');

/* previous sibling */

const last = document.querySelector('#last');
log(last);

let previous = last.previousSibling.previousSibling;
log(previous);

*******************************
NEXT / PREVIOUS ELEMENT SIBLING
*******************************
Idem démarche précédente (previous / next sibling), 
mais plus rapide:

/* next element sibling */
const first = document.querySelector('.first');
log(first.nextElementSibling.style.color = 'red')


/* previous element sibling */

const last = document.querySelector('#last');
log(last.previousElementSibling.style.color = 'yellow')

*************************
TEXT CONTENT & NODE VALUE
*************************
  A node list is an array like object.

  <body>
    <h1 id="special">This is a special content</h1>
  </body>

  //nodeValue
const item  = document.getElementById('special');
log(item.nodeValue);            //null
log(item.childNodes);           //Node list wich is an array like object
log(item.childNodes[0].nodeValue);
//OU
log(item.firstChild.nodeValue); //This is a special content

//OU textContent
log(item.textContent);          //This is a special content

******************
GET /SET ATTRIBUTE
******************
Syntaxe:
  //Récupérer un élément:
  const element = document.selector('type d'attribut');
  //Récupérer la valeur d'un autre attribut de cet élément:
  const attributValeur = element.getAttribute('un autre type d'attribut); 

<ul>
    <li class="1erAtt first" id="2emeAtt">I have class of first</li>
    <a href="first.html" id="link">random link</a>
    <li>I have no attributes</li>
</ul>

//GET ATTRIBUTE
const first = document.querySelector('.first'); //Récupère 1er élément ".first"
const classValue = first.getAttribute('id'); //1er attribut de type 'id'(class..)
log(classValue);                             // valeur de l'attribut:"2emeAtt"
//log(firstValue.textContent);               // text of class of first.

const link = document.getElementById('link');
const linkValue = link.getAttribute('href');
log(linkValue);


//SET ATTRIBUTE
let allFirstElements = document.querySelectorAll('.first');
log(allFirstElements);                       //NodeList

const last = link.nextElementSibling;        //Récupérer le dernier élément
log(last);
last.setAttribute('class', 'first');               //Lui affecter une classe
last.textContent = 'I now have a class attribute'; //et corriger le textContent
log(last);

allFirstElements = document.querySelectorAll('.first');
log(allFirstElements);

*****************
CLASS LIST / NAME
*****************
   <ul>
    <h1 id="first" class="colors">I am first element</h1>
    <h1 id="second">I am second element</h1>
    <h1 id="third">I am third element</h1>
  </ul>

const first = document.getElementById('first');
const second = document.getElementById('second');
const third = document.getElementById('third');

first.className = 'text';       //className 'text' replaces 'colors'
log(first);

second.classList.add('class1');
log(second);
second.classList.add('class2');
log(second.classList);           //['class1', 'class2', value:'class1 class2']
log(second.classList.value);     //class1 class2

second.classList.remove('class1');

****************************************
CREATE ELEMENT / TEXTNODE - APPEND CHILD
****************************************
//Create empty 'div'
const bodyDiv = document.createElement('div');
//Create text node
const text = document.createTextNode('A simple body div');
//Append the text node to the bodyDiv
bodyDiv.append(text);
document.body.append(bodyDiv);
bodyDiv.classList.add('blue');      //CSS
log(bodyDiv);

*************
INSERT BEFORE
*************
Syntaxe: insertBefore(element, location)
On insère derrière un élément statique (pas un autre élément dynamique ?)

const result = document.getElementById('result');//element statique
log(result); 

const heading = document.createElement('h2');
const textHeading = document.createTextNode('dynamic heading');
heading.append(textHeading);

document.body.insertBefore(heading, result);    //object, location 
heading.classList.add('red');      

*************
REPLACE CHILD
*************
Syntaxe: document.body.replaceChild(élément remplacé, élément remplaçant);

- Ex1
let smallHeading = document.createElement('h6');
let smallHeadingText =document.createTextNode('I am small heading');
smallHeading.append(smallHeadingText);
smallHeading.classList.add('red');
document.body.append(smallHeading);

document.body.replaceChild(smallHeading, bodyDiv); 
log(smallHeading);

*******************
PREPEND, INNER TEXT
*******************
<body> 
   <h1>FIRST HEADING</h1>
</body>

const heading = document.createElement('h2');
heading.innerText = 'I am a dynamic heading';
document.body.prepend(heading);     //prepend (before) != append (after)

***********************
REMOVE(), REMOVECHILD()
***********************
   <h1>Hello world</h1>
   <div id="result">
    <h1>second heading</h1>
   </div>

const result = document.querySelector('#result');
//result.remove();
const heading = result.querySelector('h1');
log (heading); 
heading.remove();   
// OU
//result.removeChild(heading);

************************
INNER HTML, TEXT CONTENT
************************
  <ul id="first">
    <li class="item">list item</li>
    <li>list item</li>
  </ul>
  <div id="second">
    I have some text content
  </div>

const list = document.getElementById('first');
const div = document.getElementById('second');
const item = document.querySelector('.item');

//log(div.textContent);
//log(list.innerHTML);        //To get entire HTML of an element
//log(list.textContent)       //Just the text

//Recopier du HTML dans un nouvel élément créé dynamiquement:
let var1 = 'bla bla'
const ul = document.createElement('ul');
ul.innerHTML = `<li class="item">list item</li>
    <li>list item</li><li>${var1}</li>`;
log(ul);
document.body.append(ul);

******************************
CHANGE CSS WITH STYLE PROPERTY
******************************
<style>
      .title{
        font-size: 3rem;
        background: blue;
        color: white;
        text-transform: capitalize;
        width: 90%;
        text-align: center;
      }
</style>
    .../..
<div class="random">
    I am just some random div looking for CSS
</div>

const random = document.querySelector('.random');
log(random);

/* random.style.background = 'blue';
random.style.color = 'white';
random.style.fontSize = '3rem';
random.style.textTransform = 'capitalize';
random.style.width = '90%';
random.style.textAlign = 'center'; */

//Plus rapide:
random.classList.add('title');

/*********************************************** E V E N T S ***********************************************/

***********
CLICK EVENT 
***********
<style>
     .red{
      background: red;
      color: white;
      text-transform: uppercase;
      font-size: 2rem;
     }

     .blue{
      height: 4rem;
      width:20rem;
      font-size: 2rem;
      padding-top: 12px;
      background: blue;
      color: white;
      text-align: center;
     }

     .btn{
      background: red;
      color: white;
      font-size: 1.2;
      border: none;
      cursor: pointer;
     }
    </style>

    * {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-size: 1.5rem;
}

 p, div{
  width: 12rem;
  background: aqua;
  margin: 2rem auto;
  text-align: center;
}

let btn = document.querySelector('.btn');   //1 - Select an element
let heading = document.querySelector('h2');
btn.addEventListener('click', function(){   //2 - Which type of event
     heading.classList.add('red');          //Pas de point '.red'!!!
     log(heading.classList);                //3 - Which callback to be executed
})

******************
FUNCTION REFERENCE
******************
let btn = document.querySelector('.btn');   //1 - Select an element
let heading = document.querySelector('h2');

let switchClasse = function(){
 if(heading.classList.contains('red')){
    heading.classList.remove('red');
    heading.classList.add('blue');
 } else {
    heading.classList.remove('blue');
    heading.classList.add('red');    
 }
}

btn.addEventListener('click', switchClasse);

************
MOUSE EVENTS
************
mousedown, mouseup, mouseenter, mouseleave

let heading = document.querySelector('h2');
let btn = document.querySelector('.btn');

btn.addEventListener('click', function(){
    log('You have clicked me')
})

btn.addEventListener('mousedown', function(){
    log('mousedown')
})

btn.addEventListener('mouseup', function(){
    log('mouseup')
})

heading.addEventListener('mouseenter', function(){
    heading.classList.add('blue');
})

heading.addEventListener('mouseleave', function(){
    heading.classList.remove('blue');
})

**********
KEY EVENTS
**********
keypress, keyup, keydown

 <label for="fname">Name:</label>
      <input type="text" id="fname">

const nameInput = document.querySelector('#fname');
log(fname);

/* nameInput.addEventListener('keypress', function(){
    log('You pressed the keyboard')
})

nameInput.addEventListener('keydown', function(){
    log('You pressed a keydown')
}) */

nameInput.addEventListener('keyup', function(){
    log('You pressed the keyup');
    log(nameInput.value);
})

keyup permet de récupérer une valeur saisie !

************
EVENT OBJECT
************
  Vocabulaire: 
  - event.currentTarget, l'élément auquel est attaché  l'écouteur
  (eventListener).
  - event.type: click, mouseenter, keypress, keyup...

  <div class="enter">
     <button class="btn">Click me</button>
     <h1>some heading</h1>
     <a href="#" id="link">random link</a>
  </div>

const heading = document.querySelector('h1');
const btn = document.querySelector('.btn')
const link = document.querySelector('#link')
log(link);

heading.addEventListener('click', function(event){  //Evénement et action
    log(event.type);                                //Click 
    log(event.currentTarget);                       //<h1> ../..</h1>
    heading.classList.add('blue');
})

btn.addEventListener('click', function(event){
    event.currentTarget.classList.add('blue');
    log(btn.classList);
})

function someFunc(evt){
    evt.preventDefault();                           //Evite un retour au haut de la page ???
}
link.addEventListener('click', someFunc); 

***********************
CURRENT TARGET - TARGET
***********************
 <body>
    <button class="btn">first button</button>
    <button class="btn">
      second <strong> button <strong>more nested</strong></strong>
    </button>
    <button class="btn">third button</button>
  </body>

  let btns = document.querySelectorAll('.btn');
  log(btns);

btns.forEach(function(btn){
    btn.addEventListener('click', function(e){
      log(e.currentTarget);
 //e.currentTarget.style.color='green';//Element which receenerived the listener
      e.target.style.color = 'green';  //The targeted fraction of the element
    })
})

**************************************
EVENT PROPAGATION - BUBBLING, CAPTURING
**************************************
Select dynamic elements !
Event propagation: the order in which events are fired.
Bubbling: clicked elements first then bubbles up - default.
Capturing: fires at the root and fires until it reaches target. 

<body>
   <div class="container">
    <ul class="list-items">
      <li class="item"><a href="#" class="link">1 link</a></li>
      <li class="item"><a href="#" class="link">2 link</a></li>
      <li class="item"><a href="#" class="link">3 link</a></li>
    </ul>
   </div>
</body>

BUBBLING:
let container = document.querySelector('.container');
let list = document.querySelector('.list-items');

function showBubbling(e){
  log('current target', e.currentTarget);
  log('target', e.target);
  if(e.target.classList.contains('link')){
    log('You clicked on the link');
  }
}

function stopPropagation(e){
  log('You clicked on the list')
  e.stopPropagation();
}

list.addEventListener('click', stopPropagation);

            //OU

list.addEventListener('click', showBubbling);
//container.addEventListener('click', showBubbling);
//document.addEventListener('click', showBubbling);
//window.addEventListener('click', showBubbling);

CAPTURING:

list.addEventListener('click', showBubbling, {capture:true});
container.addEventListener('click', showBubbling, {capture:true});
document.addEventListener('click', showBubbling, {capture:true});
window.addEventListener('click', showBubbling, {capture:true});

***************************
EVENT PROPAGATION - EXAMPLE
***************************
<div class="container">
    <h1 class="heading">I am sitting inside container</h1>
   </div>
<button class="btn">click me</button>

const container = document.querySelector('.container');
const heading = document.querySelector('.heading');
const btn = document.querySelector('.btn');
log(heading);

const sayHello = function(){
  log('Hello there !');
}
heading.addEventListener('click', sayHello);

//Créer des elmts dynamiquement:
btn.addEventListener('click', function(){
  let elmt = document.createElement('h1');
  elmt.classList.add('heading');
  elmt.textContent = 'I am siting in the container';
  container.appendChild(elmt);
})

*****
FORMS
*****
<form action=" " id="form">
    <input type="text" id="fname">
    <input type="password" id="password">
    <input type="submit" id="submit">
</form>

const form = document.querySelector('#form');
const fname = document.querySelector('#fname');
const password = document.querySelector('#password');

form.addEventListener('submit', function(e){
  e.preventDefault();    //To avoid sending the data and 
                         //Cleaning the screen ("action")
  log('Form submitted');
  log(fname.value);
  log(password.value);
})

*************
LOCAL STORAGE
*************
setItem, getItem, removeItem, clear.
session storage, local storage.
Aller dans "devtools" (Console, Eléments...Appli) sur "Appli".

Toutes les clés ddoivent être différentes:
localStorage.setItem('name', 'john');     //Crée un article
localStorage.setItem('name', 'peter');    //Efface la ligne précédente
localStorage.getItem('name');             //Retourne 'peter'
localStorage.removeItem('name');          //Supprime 'peter'
localStorage.clear();                     //Supprime tout le localStorage

**********************************
LOCAL STORAGE WITH MULTIPLE VALUES
**********************************
JSON.stringify(), JSON.parse();
Pour stocker des arrays ou des objets, il faut utiliser ces 2 fonctions.

const friends = ['john', 'peter', 'bob']
localStorage.setItem('friends', JSON.stringify(friends));//Ecrire en localStorage

const values = JSON.parse(localStorage.getItem('friends'));//Lire en localStorage
log(values);

let fruits;

if(localStorage.getItem('fruits')){
  fruits = JSON.parse(localStorage.getItem('fruits'));
}else{
  fruits = [];
}

log(fruits);
fruits.push('apple');
log(fruits);
fruits.push('orange');
localStorage.setItem('fruits', JSON.stringify(fruits));//Ecrire en localStorage
localStorage.removeItem('fruitss');

**********
SETTIMEOUT
**********
  Syntaxe: setTimeout(reference function, delay);  on window object.
  Default is 0 for delay 
  Retourne un identifiant unique(id1)

//-Ex1
let sayHello = function(fname, score){
  log(`Hi ${fname} your score is ${score}`)
}

let delay = 5000;
setTimeout(sayHello('Toto', 50), delay);            //Hi Toto your score is 50 
clearTimeout();

let id1 = setTimeout(sayHello('Titi', 80), delay);  //Hi Titi your score is 80
clearTimeout(id1);

***********
SETINTERVAL
***********
Très semblable à SETTIMEOUT, mais la fonction de référence
est répéte après chaque chaque période d'une durée "delay".

***************************
EVENTS - DOM CONTENT LOADED
***************************
  The "DOMContentLoaded" event fires when the initial 
  HTML Document has been loaded & parsed without
  waiting for CSS, images or subframes to be loaded.

  window.addEventListener('DOMContentLoaded', function(){
  log('Hi there, HTML was loaded');
  const heading = document.querySelector('h1');
  log(heading);
  heading.style.color = 'red';
})

*************
EVENTS - LOAD
*************
  The "load" event fires when aii resources have been loaded,
  including CSS, images and others. This event takes more 
  time than "DOMContentLoaded" in particular if CSS and images
  are large files.

  window.addEventListener('load', function(){
  log('I will load second');
  const heading = document.querySelector('h1');
  log(heading);
  heading.style.color = 'red';
})

***************
EVENTS - SCROLL
***************
  "scroll" donne la valeur du déplacement sur les 2 axes.

<body>
     <img src="./pexels-muffin-1653877.jpg" alt="Pizza">   
</body>

window.addEventListener('scroll', function(){
  log(this.window.scrollY + ' px');
  log(this.window.scrollX + ' px');
})

************************************
WIDTH, HEIGHT, GETBOUNDINGCLIENTRECT()
**************************************
- innerWidth: the read only window property returns  the interior 
width of the window in pixels.
- innerHeight: the read only window property returns the interior
height of the window in pixels.
- The element.getBoundingCientRect() method returns a DOMRect object provides
information about the size of an element and its position relative 
to the viewport. 

-Ex1:
index.html:

  <style>
    .btn{
      margin: 1rem;
      font-size: 1.5rem;
    }
    .box{
      margin: 1rem;
      width: -3rem;
      height: 10rem;
      background: red;
    }
  </style>

 <h1>Javascript</h1>
 <button class="btn">click me</button>
 div class="box"></div> 

app.js:

/* log('window innerHeight: ' + window.innerHeight);
log('window innerWidth: ' + window.innerWidth);
 */
const btn = document.querySelector('.btn');
const box = document.querySelector('.box');

btn.addEventListener('click', function(){
  const values = box.getBoundingClientRect();
  log(values);
})

*************
EVENTS RESIZE
*************

The "resize" event fires when the size of the window resizes.

window.addEventListener('resize', function(){
  log(this.window.innerWidth);
  log(this.window.innerHeight);
})

/*========================================= O B J E C T S =================================*/
 
******
BASICS
******
const person ={
  fname: 'Paul',
  lname: 'Martin',
  age: 70
}

let ageSupprime = delete person.lname;
log(ageSupprime);   //true

log(person); 

*********************************
NESTED OBJECTS - BRACKET NOTATION
*********************************
=> Nested object(s):
const person ={
  fname: 'Paul',
  lname: 'Martin',
  age: 70,
  job:{
    title:'developper',
    salary:2000,
    company:{
      raison_sociale:'Google',
      adresse: 'Californie'
    }
  }
}

log(person.job.company.adresse);  //Californie

=> const age = 40;

const person ={
  fname: 'Paul',
  lname: 'Martin',
  age: age,
  job:{
    title:'developper',
    salary:2000,
    company:{
      raison_sociale:'Google',
      adresse: 'Californie'
    }
  }
}

log(person.age) // 40

=> Square bracket NOTATION
   const user ={
    fname: 'Paul',
    lname: 'Martin',
  }

// set
user["likes birds"] = true; log(user);

// get
alert(user["likes birds"]); // true

// delete
delete user["likes birds"];  log(user);

****
THIS
****

"THIS" is left of the dot and designates the object:
const john = {
  fname: 'john',
  lname: 'anderson',
  fullName: function (){
    log(this);         //{fname: 'john', lname: 'anderson', fullName: ƒ}
    log(`My full name is ${this.fname} ${this.lname}`);
  },                   //My full name is john anderson
}

john.fullName();       //The function "fullName()" is called on "john",
                       //left of the dot, ".".

=> THIS with regular functions (function name () {})
   
   Ex1: log(this)   // window in the global scope

   Ex2:  function showThis(){
            log(this);
         }

const john ={
  name:'john',
  showThis: showThis,
}

const paul ={
  name:'paul',
  showThis: showThis,
}

john.showThis();  //{name: 'john', showThis: ƒ} left of the dot is john
paul.showThis();  //{name: 'paul', showThis: ƒ} left of the dot is paul

=> THIS with arrow functions is another topic 

****************
FACTORY FUNCTION
****************
function createPerson(fname, lname){
  return {
    fname: fname,
    lname: lname,
    fullName:function(){
      log(`My name is ${fname} ${lname} and I love JS`)
    }
  }
}

const person1 = createPerson('Georges', 'NORDON'); 
log(person1);
person1.fullName();

***********
CONSTRUCTOR
***********
function CreatePerson (fName, lName){     //Majuscule
  this.fName = fName,                     //utilisation de this ..=
  this.lName = lName,
  this.fullName = function(){
      log(`My name is ${fName} ${lName} and I love JS`)
    }
};

const georges = new CreatePerson('Georges', 'NORDON');  //new !!!
log(georges);
georges.fullName();

*********
PROTOTYPE
*********
  Prototype: une propriété de la fonction CONSTRUCTOR qui permet de 
  stocker des données qui sont communes à toutes les occurrences
  attachées au CONSTRUCTOR.
  Exemple: Account.prototype.bank //La banque est la même pour tous les comptes
                                  //d'une même banque.

Ex1:
function CreatePerson (fName, lName){
    this.fName = fName,
    this.lName = lName
  }

const georges = new CreatePerson('Georges', 'NORDON');
log(georges);

CreatePerson.prototype.bank = 'BNP';            //property in the prototype

CreatePerson.prototype.fullName = function(){   //method in the prototype
      log(`My name is ${this.fName} ${this.lName}, my bank is ${this.bank}`)
    }

georges.fullName();

******
LOOKUP
******
   When lookig for a property (or a method), the system looks first in the
   object. If the property cannot be found there, the system looks into 
   the prototype. 
   When creating an object or an array this object / array is not stored 
   on the object itself but above on the prototype. Beyond the prototype
   itself we have another level of "proto" with the Constructor.

*********
ES6 CLASS
*********

class Account {
  constructor(fname, accountBalance){
    this.fname = fname;
    this.balance = accountBalance;
  }
}
Ex1:
const georges = new Account('Georges', 1000);
Account.prototype.bank = "BNP";
log(georges);   //Account {fname: 'Georges', balance: 1000}
                          balance: 1000
                          fname: "Georges"
                          [[Prototype]]: Object 
                          bank: "BNP"
                          constructor: class Account
                          [[Prototype]]: Object
Ex2:
Account.prototype.bank = "Chase";
Account.prototype.solde = function(){
  log(`Mon solde est de ${this.balance}`)};
const georges = new Account('Georges', 1000);

georges.solde();      //Mon solde est de 1000

log(georges);         //Account {fname: 'Georges', balance: 1000}
                      /* [[Prototype]]: Object
                         bank: "Chase"
                         solde: ƒ () */

*****************
CALL, APPLY, BIND
*****************
=> CALL:
Ex1:
  const john = {
  fname : 'john',
  age : 24,
  greet: function(){
    log(this);
    log(`My name is ${this.fname} and I am ${this.age} years old`)
  }
}

const susan = {
  fname: 'susan',
  age:21,
}
john.greet();             //{fname: 'john', age: 24, greet: ƒ}
                          //My name is john and I am 24 years old

john.greet.call(susan);   //{fname: 'susan', age: 21}
                          //My name is susan and I am 21 years old
et aussi john.greet.call(john);

Ex2:
const susan = {
  fname: 'susan',
  age:21,
}

function greet(){
    log(this);
    log(`My name is ${this.fname} and I am ${this.age} years old`)
}

greet.call(susan);       //{fname: 'susan', age: 21}
                         //My name is susan and I am 21 years old

=> APPLY
Ex1:
const john = {
  fname : 'john',
  age : 24,
  greet: function(city, country){
    log(this);
    log(`My name is ${this.fname} and I am ${this.age} years old and I 
      live in ${city} ${country}`)
  }
}

john.greet.apply(john, ['San diego', 'USA']);
john.greet.apply({fname:'Peter', age:30}, ['San diego', 'USA']);

=> BIND
  With the bind() method, an object can borrow a method from another object.
Ex1:
const person = {
  firstName:"John",
  lastName: "Doe",
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}

const member = {
  firstName:"Hege",
  lastName: "Nilsen",
}
  //Assign, call it later:
let fullName = person.fullName.bind(member);
document.getElementById("demo").innerHTML = fullName();

Ex2:
const btn = document.querySelector('.increment'); log(btn);
 
const counter = {
  count:0,
  increment(){
    log(this);
    this.count++
    log(this.count);
  }
}

let compteur = counter.increment.bind(counter);//!!!

btn.addEventListener('click', compteur);

/****************************************** F U N C T I O N S ******************************************/

****
IIFE
****
Immediately Invoked Function Expression. Les IIFE empêchent la pollution de la portée globale de JavaScript.

********
HOISTING
********
Avoid using variables before they have been declared !

*******
CLOSURE
*******
Ex1:
function newAccount(name, newBalance){
  let balance = newBalance;
  function showBalance(){
    log(`${name}, your balance is ${balance}`);
  }
  return showBalance;
}
   
log(newAccount('Georges', 1000)());
log(newAccount('Hélène', 2000)());

Ex2:
function newAccount(name, newBalance){
  let balance = newBalance;
  function showBalance(){
    log(`${name}, your balance is ${balance}`);
  }

  function deposit(amount){
    balance += amount; 
  }

  function withDraw(amount){
    if((balance - amount) < 0 ){log('Balance is insufficient');}
    else{balance -= amount}
    } 
    return {showBalance: showBalance, deposit:deposit, withDraw:withDraw};
  }

const alice = newAccount('Alice', 3000);
log(alice);
alice.showBalance();
alice.deposit(1000);
alice.showBalance();
alice.withDraw(500);
alice.showBalance();
alice.withDraw(5000);
